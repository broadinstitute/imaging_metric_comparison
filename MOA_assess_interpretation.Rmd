---
title: "MOA assess interpretation"
output: html_document
---

```{r setup, include=FALSE}
library(magrittr)
library(dplyr)
library(foreach)
library(doMC)
library(reshape2)
library(stringr)
```

## Parameters
```{r parameters}
# top percentage of matching compound.
top.x <- 0.02

# for reproductibility
seed <- 42
set.seed(seed)

# number of CPU cores for parallelization
registerDoMC(7)

# number of sample used for baseline
N <- 1000 
```

## Import data

```{r import data, message=FALSE}

filename <- "Hit_pearson_random_500_5988.rds" #"Hit_jaccard_30n_FS2_svd_5950.rds" 
#"Hit_jaccard_30n_FS2_svd_5950.rds", "Hit_jaccard_30n_fs_6206.rds", "Hit_jaccard_50n_6225.rds", "Hit_pearson_FS2_svd_6438.rds", "Hit_pearson_fs_5975.rds", "Hit_pearson_5925.rds", "Hit_pearson_SVD_sc_500_6106.rds", "Hit_jaccard_30n_SVD_sc_500_5856.rds", "Hit_jaccard_30n_random_500_6081.rds", "Hit_pearson_random_500_5988.rds"

pf <- readRDS(file.path("..", "..", "input", "BBBC022_2013", "single_cells", filename))

profiles <- pf$data

variables <- pf$feat_cols
```

## Metadata 

Select compounds that have a MOA that is at least shared with another compounds. In final 88 MOAs are selected. For 412 compounds.
moa size: 432x3 (because some compounds have more than 1 MOA)
```{r MOAs}
# import MOAs data
moa <- 
  read.csv("../../input/BBBC022_2013/MOAs.csv", na.strings = c("", "NA")) %>%
  mutate_if(is.factor, as.character) # has to do that to duplicate rows where multiple MOA

moa %<>% 
  filter(!is.na(MOA_group)) %>% # remove rows where moa = NA
  rename(Image_Metadata_SOURCE_COMPOUND_NAME = Name) # rename compound name

# remove duplicate compounds
moa$Image_Metadata_SOURCE_COMPOUND_NAME <- toupper(moa$Image_Metadata_SOURCE_COMPOUND_NAME) # put compound names in upper character (to make it comparable)
moa %<>%
  group_by(Image_Metadata_SOURCE_COMPOUND_NAME) %>%
  slice(1) %>%
  ungroup

# duplicate rows where multiple MOA associated to one compounds
for (i in 1:nrow(moa)){
  # if there are more than 1 moa associated
  if (str_detect(moa$MOA_group[i], ",")){
    t1 <- str_trim(str_split(moa$MOA_group[i], ",")[[1]])
    moa$MOA_group[i] <- t1[1]
    new.row <- moa[i,]
    new.row$MOA_group <- t1[2]
    moa <- rbind(moa, new.row)
  }
}
```

Compound-ID: 959 unique (same number as in the other!)
```{r compound-id}
# mapping IDs-Compounds: give access to the compound knowing the IDs
id.cmpds <-
  pf$data %>%
  dplyr::select(one_of(c("Image_Metadata_BROAD_ID","Image_Metadata_SOURCE_COMPOUND_NAME"))) %>% # select ID and Compound
  mutate_if(is.character, funs(toupper)) %>% # same compound can be writen in upper and lower case and looks different# be sure it is a dataframe
  group_by(Image_Metadata_SOURCE_COMPOUND_NAME) %>%
  slice(1) %>%
  ungroup
```

```{r metadata}
# metadata: compound, MOA, target, ID
metadata <- 
  moa %>%
  left_join(., id.cmpds, by = "Image_Metadata_SOURCE_COMPOUND_NAME")

# select only rows that have a BROAD_ID
metadata %<>% filter(!is.na(Image_Metadata_BROAD_ID))

# select MOA that are appearing more than once (meaning at least two compounds are related to it)
n.MOA <- table(metadata$MOA_group) %>% as.data.frame() %>% filter(Freq != 1)
metadata %<>%  filter(MOA_group %in% n.MOA$Var1)
```

## Profiles of the compound

Do the average along replicates.

```{r compound profile}
# average along replicate (keep only id and variables)
pf.cmpds <-
  pf$data %>%
  filter(Image_Metadata_BROAD_ID %in% metadata$Image_Metadata_BROAD_ID) %>% # select ID that have a unique compound
  group_by(Image_Metadata_BROAD_ID) %>% 
  summarise_each(funs(mean(., na.rm=TRUE)), -c(Image_Metadata_SOURCE_COMPOUND_NAME, Well, Plate)) %>% # mean along replicate
  ungroup %>%
  as.data.frame()

# keep track of ID of the compounds
row.names(pf.cmpds) <- pf.cmpds$Image_Metadata_BROAD_ID
```

## Combination profile + metadata

```{r profile + metadata}
# Attention: since some compounds have more than one MOAs, few rows have same compounds name.
pf.cmpd.meta <- 
  metadata %>%
  dplyr::left_join(., pf.cmpds, by = "Image_Metadata_BROAD_ID") %>%
  as.data.frame
dim(pf.cmpd.meta)
```

## Number of MOA in common for each compounds pair

```{r}
# binary indicator matrix of ID vs MOA 
n.moa.ID <- 
  pf.cmpd.meta %>%
  select(MOA_group, Image_Metadata_BROAD_ID) %>%
  table %>%
  as.data.frame.matrix %>%
  as.matrix

# number of moa in common for each ID pairs
n.moa.cmpd.pair <-
  t(n.moa.ID)  %*% n.moa.ID %>% # calculate matrix compound ID - compound ID relation
  melt(.) %>% # transform matrix into column
  filter(Var1 != Var2)

```


## Correlation compound-compound 

```{r correlation cmpd-cmpd}
# correlation compound-compound
cor.cmpd <-
  pf.cmpds[, pf$feat_cols] %>% 
  as.matrix() %>%
  t() %>%
  cor()
```

## Number MoAs matching
Number of MoA that are matching a particular MoA 

```{r function matching moa}
number.matching.moa <- function(cor.mat, n.moa.cmpd.pair){
  cor.cmpd.pair <- 
    cor.mat %>%
    left_join(.,
              n.moa.cmpd.pair,
              by = c("cmpd1" = "Var1", "cmpd2" = "Var2"))
  
  X <- 
    cor.cmpd.pair %>%
    arrange(desc(corr)) %>% # sort correlation from higher to lower
    filter(corr > quantile(corr, 1.0-top.x)) %>% # look at the top X% correlation in each group
    filter(value > 0) %>% # at least one MoA in common
    summarise(p = n()) %>% # count number of times MoAs are matching
    as.numeric()

  return(X)
}

```

##

```{r function to calcualte correlation matrix for one MoA}
moa.cor.function <- function(moa.name){
  # extract compound that have the particular MoA of interest
  test <- pf.cmpd.meta %>% filter(MOA_group %in% moa.name)
  
  # extract correlation rows of interest
  test.cor <- cor.cmpd[rownames(cor.cmpd) %in% test$Image_Metadata_BROAD_ID, ]

  test.cor %<>% 
    melt() %>% 
    filter(value != 1) %>% # remove correlation of 1 (meaning it is correlated to itself)
    rename(cmpd1 = Var1, cmpd2 = Var2, corr = value)
  
  return(test.cor)
}

 moa.random.cor.function <- function(moa.name, seed_){
  # extract compound that have the particular MoA of interest
  test <- pf.cmpd.meta %>% filter(MOA_group %in% moa.name)

  # extract correlation rows of interest
  test.cor <- cor.cmpd[rownames(cor.cmpd) %in% test$Image_Metadata_BROAD_ID, ]
  
  # switch name of the column
  col.name <- colnames(test.cor) # extract names of the columns to shuffle

  # for reproducibility
  set.seed(seed_)
  # randomly shuffle names of the compounds
  col.name.shuffle <- sample(col.name)
  
  # shuflle in the same random way the names of the rows and the columns
  colnames(test.cor) <- col.name.shuffle
  
  test.cor %<>% 
    melt() %>% 
    filter(value != 1) %>% # remove correlation of 1 (meaning it is correlated to itself)
    rename(cmpd1 = Var1, cmpd2 = Var2, corr = value)
  
  return(test.cor)
}
```

##

```{r}
# list of MoAs
# for each unique MOA -> do a function for one particular MOA and then do a for loop
all_moa <- unique(pf.cmpd.meta$MOA_group)

moa.enr.ratio <- data.frame(MOA = all_moa)
top.num.moa <- c()

# for all moa
for(m in all_moa){
  # calculate the correlation matrix for this particular MoA
  test.cor <- moa.cor.function(m)
  
  # calculate number of matching MoA in top 2% for a particulat MoA
  top.num.moa <- c(top.num.moa, number.matching.moa(test.cor, n.moa.cmpd.pair))
}

moa.enr.ratio %<>% mutate(X = top.num.moa)

```


```{r baseline}

set.seed(seed)

seeds <- sample(1:10000, N, replace=F)

X.random <- c()

# for all moa
for(m in all_moa){
  print(m)
  print(match(m,all_moa))
  top.num.moa.random <- foreach(i = 1:N, .combine=cbind) %dopar% {
    # for reproducibility
    seed_ <- seeds[i]

    # calculate the correlation matrix but with random compounds
    test.cor.random <- moa.random.cor.function(m, seed_)
    
    # calculate the number of matching MoA in top 2% for a particular MoA
    top.num.moa.random <- number.matching.moa(test.cor.random, n.moa.cmpd.pair)
  }
  
  X.random <- c(X.random, mean(top.num.moa.random))
}

moa.enr.ratio %<>% mutate(X.random = X.random)

```

```{r}

final.moa.enr.ratio <- moa.enr.ratio %>% mutate(enr.ratio = X/X.random) %>% arrange(desc(enr.ratio))

save(final.moa.enr.ratio, file="Pearson_random_500_enr_ratio.Rda")

```






