---
title: "Replicate Correlation"
output:
  html_document: default
---
The goal is to do some Hit Selection. Selecting the compound that have effects, that are showing a phenotype.
Find the median replicate correlation.
Use Pearson correlation.

Use different type of correlation metric

## Data

The input data is a 7680 by 803 matrix.
There are 7680 different observations and 799 features (extracted with CellProfiler).
Each compound (1600 different) has 4 replicates. The negative control has 1280 replicates.
20 plates with 384 wells in each plate.

```{r setup, include=FALSE}
# all usefull libraries
library(magrittr)
library(dplyr)
library(ggplot2)
library(foreach)
library(doMC)
library(stringr)
library(tidyverse)
```

## Parameter
```{r parameter}
# name of the data file
filename <- "BBBC022_2013_sel_feat.csv"

# method of correlation: "pearson", "kendall", "spearman"
cor.method <- "pearson"

# number of data to make the non replicate correlation (random distribution)
N <- 5000

# seed for the reproducibility
set.seed(42)

```

## Import data
```{r import data with feature selection, message=FALSE}
# import data
profiles <- 
  readr::read_csv(file.path("..", "..", "input", "BBBC022_2013", filename)) # 7680x(nfeat+metadata)

variables <-
  names(profiles) %>% str_subset("^Cells_|^Cytoplasm_|^Nuclei_") # nfeat

metadata <-
  names(profiles) %>% str_subset("^Metadata_") # metadata

# Remove the negative control (DMSO) from the data
profiles %<>% 
  filter(!Metadata_broad_sample %in% "DMSO") # 6400xnfeat
```

```{r import data no feature selection, message=FALSE, eval=FALSE}
profiles <- 
  list.files("../../backend/BBBC022_2013/", 
          pattern = "*_normalized.csv",
          recursive = T,
          full.names = T) %>%
  map_df(read_csv)

dim(profiles)

variables <-
  names(profiles) %>% str_subset("^Cells_|^Cytoplasm_|^Nuclei_")

metadata <-
  names(profiles) %>% str_subset("^Metadata_")
  
# remove zero variance data
profiles %<>%
  cytominer::select(
    sample = 
      profiles %>% 
      filter(Metadata_pert_type == "control"),
    variables = variables,
    operation = "variance_threshold"
  )

variables <-
  names(profiles) %>% str_subset("^Cells_|^Cytoplasm_|^Nuclei_")

# Remove the negative control (DMSO) from the data
profiles %<>% 
  filter(!Metadata_broad_sample %in% "DMSO") # 6400xnfeat

```

## Separation of data

Separation is made according to the compound that was added.
Metadata_broad_sample = gives the ID of the compound that was added.

```{r separation of data}
# find the different compounds
IDs <- distinct(profiles, Metadata_broad_sample)
dim(IDs)
```

## Correlation of the data

Calculate the correlation of the replicate for each compound.
In an ideal case, all the correlation should be 1, meaning that they are highly correlated.

```{r correlation in parallel}
# computational time
start.time <- Sys.time()

registerDoMC(7)  # number of CPU cores  

comp.cor.median <- foreach(i = 1:length(IDs$Metadata_broad_sample), .combine=cbind) %dopar% {

  #filtering to choose only for one compound
  comp <-
    filter(profiles, Metadata_broad_sample %in% IDs$Metadata_broad_sample[i])
  comp <-
    comp[, variables] %>% # take only the features
    as.matrix()

  # correlation of the features according to the method chosen in the parameter (pearson, spearman or kendall)
  comp.cor <- cor(t(comp), method = cor.method)
  
  # save median of the correlation
  comp.cor.median <- median(comp.cor[lower.tri(comp.cor)],na.rm=TRUE) 

}

end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 6.44 secs instead of 1.179 minutes

hist(comp.cor.median,
     main="Histogram for Median Replicate Correlation",
     xlab="Median Replicate Correlation", xlim = range(-1, 1))
```

If the value is equal to 1 it means that it is changing in the same direction (total positive linear correlation). 
0 means that they are unrelated (no linear correlation). 
-1 means that they are opposite (total negative linear correlation).
As expected for the replicate we can see that the distribution is bigger than 0 meaning that there are positively correlated.


## Thresholding of poor replicate correlation

H0: median non replicate correlation.

The Null distribution is estimated by finding the median correlation of non replicates. 
Select randomly 4 replicates each coming for a different compound and calculate the median correlation. 
Repeat this N times to get a distribution.
Finally estimate a threshold (95th percentile) to filter out compounds with poor replicate correlation.

```{r replicate correlation} 
# computational time
start.time <- Sys.time()

# set seed for reproducibility
set.seed(42)

# random sequence for reproducibility
a <- sample(1:10000, N, replace=FALSE)

# loop over N times to get a distribution
random.replicate.cor.median <- foreach(i = 1:N, .combine=cbind) %dopar% {
  # set seed according to random sequence
  set.seed(a[i])
  
  # group by IDs
  # sample fixed number per group -> choose 4 replicates randomly from different group
  random.replicate <- 
    profiles %>% 
    group_by(Metadata_broad_sample) %>% 
    sample_n(1, replace = FALSE) %>% # choose randomly 1 sample for each group of IDs
    ungroup(random.replicate)
  # choose randomly 4 samples each coming from a different group
  random.replicate <- sample_n(random.replicate, 4, replace = FALSE)
  
  # select only the features
  comp <- random.replicate[,variables] %>% 
    as.matrix()
  
  # correlation of the features using the method defined in the parameter (pearson, spearman, kendall)
  random.replicate.cor <- cor(t(comp), method = cor.method)
  
  # median of the non replicate correlation
  random.replicate.cor.median <- median(random.replicate.cor[lower.tri(random.replicate.cor)],na.rm=TRUE) # vector length N
  
}

end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 2.01 mins

# histogram plot
hist(random.replicate.cor.median,
     main="Histogram for Non Replicate Median Correlation",
     xlab="Non Replicate Median Correlation", xlim = range(-1, 1))

# threshold to determine if can reject H0
thres <- quantile(random.replicate.cor.median, .95)
print(thres)
```

As expected the distribution is around 0. Meaning that the features does not show a linear correlation.

## Hit Selection

Select strong replicates correlation comparing with the 95th percentile of the Null Distribution.

```{r Hit Selection}
# find indices of replicate median correlation > threshold
inds <- which(comp.cor.median > thres) 

# find values of the median that are hit selected
hit.select <- comp.cor.median[inds]

# find component that are hit selected
hit.select.IDs <- IDs$Metadata_broad_sample[inds]

# ratio of strong median replicate correlation (number of hit selected / total number of samples)
high.median.cor <- length(hit.select)/length(comp.cor.median)
print(high.median.cor)

```


## Results 

For previous dataset (old version)

|  Method   | Pearson | Spearman | Kendall | Euclidean | Maximum | Manhattan |
| --------- | ------- | -------- | ------- | --------- | ------- | --------- |
| N = 1000  | 0.6031  | -------- | ------- | --------- | ------- | --------- |
| N = 5000  | 0.5981  | 0.5519   | 0.5419  | 0.4606    | 0.3612  | 0.4875    |
| N = 10000 | 0.5850  | -------- | ------- | --------- | ------- | --------- |


- The best correlation method seems to be Pearson correlation metric.
- The other correlation method are a little bit lower (Spearman and Kendall)
- Distance method compared to correlation metric gives a lower ratio of hit selection (more or less 10% lower).

## Saving data

```{r output data}
# select high median correlation replicate 
profiles %<>% 
  filter(Metadata_broad_sample %in% hit.select.IDs)

# save new dataset
profiles %>%
  write_csv("../../input/BBBC022_2013/Hit_pearson_feat_sel.csv")

```

Remark: depending on the random distribution, the number of compounds selected can vary. 
Maybe should find a way to reach stabilization.



