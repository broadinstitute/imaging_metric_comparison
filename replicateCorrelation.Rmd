---
title: "Replicate Correlation"
output:
  html_document: default
---
The goal is to do some Hit Selection. Selecting the compound that have effects, that are showing a phenotype.
Find the median replicate correlation.
Use Pearson correlation.

Use different type of correlation metric

## Data

The input data is a 7680 by 803 matrix.
There are 7680 different observations and 799 features (extracted with CellProfiler).
Each compound (1600 different) has 4 replicates. The negative control has 1280 replicates.
20 plates with 384 wells in each plate.

```{r setup, include=FALSE}
# all usefull libraries
library(dplyr)
library(ggplot2)
library(foreach)
library(doMC)
```

```{r import data}
# import data
#pf <- readRDS("../input/Pf_Gustafsdottir.rds") # 7680x803

# Remove the negative control from the data
#pf$data <- filter(pf$data, !Image_Metadata_BROAD_ID %in% "") # 6400x803

##
pf <- readRDS("../input/Pf_Gustafsdottir_sel_feat.rds")
```

## Parameter
```{r parameter}
# method of correlation: "pearson" (default), "kendall", "spearman"
cor.method <- "pearson"
# number of data to make the non replicate correlation
N <- 10000

# seed for the reproducibility
set.seed(42)
```

## Separation of data

Separation is made according to the compound that was added.
Image_Metadata_BROAD_ID = gives the ID of the compound that was added.

```{r separation of data}
# find the different compounds
IDs <- distinct(pf$data, Image_Metadata_BROAD_ID) # 1600
dim(IDs)

```

## Correlation of the data

Calculate the correlation of the replicate for each compound.
In an ideal case, all the correlation should be 1, meaning that they are highly correlated.

```{r correlation in parallel}
# computational time
start.time <- Sys.time()

registerDoMC(7)  # number of CPU cores  

comp.cor.median <- foreach(variable = 1:length(IDs$Image_Metadata_BROAD_ID), .combine=cbind) %dopar% {

  #filtering to choose only for one compound
  comp <- filter(pf$data, Image_Metadata_BROAD_ID %in% IDs$Image_Metadata_BROAD_ID[variable])

  # correlation of the features
  comp.cor <- cor(t(comp[,pf$feat_cols]), method = cor.method)
  
  # save median of the correlation
  comp.cor.median <- median(comp.cor[lower.tri(comp.cor)],na.rm=TRUE) # 1600 values

}

end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 22.55 secs instead of 1.179 minutes

hist(comp.cor.median,
     main="Histogram for Median Replicate Correlation",
     xlab="Median Replicate Correlation", xlim = range(-1, 1))
```


```{r correlation, include=FALSE, eval=FALSE}
# computational time
start.time <- Sys.time()

comp.cor.median <- c()
# loop over all IDs
for (variable in IDs$Image_Metadata_BROAD_ID){ # 1600 IDs
  #filtering to choose only for one compound
  comp <- filter(pf$data, Image_Metadata_BROAD_ID %in% variable)

  # correlation of the features
  comp.cor <- cor(t(comp[,pf$feat_cols]), method = cor.method)
  
  # if not the negative control
  if(variable %in% IDs$Image_Metadata_BROAD_ID[1:3]){  
    #plot of the correlation
    # tl.pos="n" remove text legend
    corrplot::corrplot(comp.cor, tl.cex = 0.5, method = "ellipse",  tl.pos="n")
  }
  
  # save median of the correlation
  comp.cor.median <- c(comp.cor.median, median(comp.cor[lower.tri(comp.cor)],na.rm=TRUE)) # 1600 values
  
}

end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 1.179 minutes

hist(comp.cor.median,
     main="Histogram for Median Replicate Correlation",
     xlab="Median Replicate Correlation", xlim = range(-1, 1))
```

If the value is equal to 1 it means that it is changing in the same direction (total positive linear correlation). 
0 means that they are unrelated (no linear correlation). 
-1 means that they are opposite (total negative linear correlation).


## Thresholding of poor replicate correlation

H0: median non replicate correlation.

The Null distribution is estimated by finding the median correlation of non replicates. 
Select randomly 4 replicates each coming for a different compound and calculate the median correlation. 
Repeat this N times to get a distribution.
Finally estimate a threshold (95th percentile) to filter out compounds with poor replicate correlation.

```{r replicate correlation in parallel, include=FALSE, eval=FALSE}
# computational time
start.time <- Sys.time()

# loop over N times to get a distribution
random.replicate.cor.median <- foreach(i = 1:N, .combine=cbind) %dopar% {
  # group by IDs
  # sample fixed number per group -> choose 4 replicates randomly from different groups
  random.replicate <- pf$data %>% group_by(Image_Metadata_BROAD_ID) %>% sample_n(1, replace = FALSE) %>% ungroup(random.replicate)
  random.replicate <- sample_n(random.replicate, 4, replace = FALSE)
  
  # correlation of the features
  random.replicate.cor <- cor(t(random.replicate[,pf$feat_cols]), method = cor.method)
  
  # median of the non replicate correlation
  random.replicate.cor.median <- median(random.replicate.cor[lower.tri(random.replicate.cor)],na.rm=TRUE) # vector length N
  
}

end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 1.31 mins instead of 4.44 mins

# histogram plot
hist(random.replicate.cor.median,
     main="Histogram for Non Replicate Median Correlation",
     xlab="Non Replicate Median Correlation", xlim = range(-1, 1))

# threshold to determine if can reject H0
thres <- quantile(random.replicate.cor.median, .95)
print(thres)
```

```{r replicate correlation} 
# computational time
start.time <- Sys.time()

# vector of the median of non replicate correlation
random.replicate.cor.median <- c()

# loop over N times to get a distribution
for (i in 1:N){
  # group by IDs
  # sample fixed number per group -> choose 4 replicates randomly from different groups
  random.replicate <- pf$data %>% group_by(Image_Metadata_BROAD_ID) %>% sample_n(1, replace = FALSE) %>% ungroup(random.replicate)
  random.replicate <- sample_n(random.replicate, 4, replace = FALSE)
  
  # correlation of the features
  random.replicate.cor <- cor(t(random.replicate[,pf$feat_cols]), method = cor.method)
  
  # median of the non replicate correlation
  random.replicate.cor.median <- c(random.replicate.cor.median, median(random.replicate.cor[lower.tri(random.replicate.cor)],na.rm=TRUE)) # vector length N
  
}

end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 4.44 mins

# histogram plot
hist(random.replicate.cor.median,
     main="Histogram for Non Replicate Median Correlation",
     xlab="Non Replicate Median Correlation", xlim = range(-1, 1))

# threshold to determine if can reject H0
thres <- quantile(random.replicate.cor.median, .95)
print(thres)
```

## Hit Selection

Select strong replicates correlation comparing with the 95th percentile of the Null Distribution.

```{r Hit Selection}
# find indices of replicate median correlation > threshold
inds <- which(comp.cor.median > thres) # 938 out of 1600

# find values of the median that are hit selected
hit.select <- comp.cor.median[inds]

# find component that are hit selected
hit.select.IDs <- IDs$Image_Metadata_BROAD_ID[inds]

# ratio of strong median replicate correlation
high.median.cor <- length(hit.select)/length(comp.cor.median)
print(high.median.cor)

```


## Results

|  Method   | Pearson | Spearman | Kendall | Euclidean | Maximum | Manhattan |
| --------- | ------- | -------- | ------- | --------- | ------- | --------- |
| N = 1000  | 0.6031  | -------- | ------- | --------- | ------- | --------- |
| N = 5000  | 0.5806  | 0.5519   | 0.5419  | 0.4606    | 0.3612  | 0.4875    |
| N = 10000 | 0.5850  | -------- | ------- | --------- | ------- | --------- |


- Difference between Pearson and Spearman correlation seem not to be very significant (no statistical test was performed).
- Distance method compared to correlation metric gives a lower ratio of hit selection (more or less 10% lower).

## Saving data

```{r output data}
# select high median correlation replicate
pf$data <- filter(pf$data, Image_Metadata_BROAD_ID %in% hit.select.IDs) # 3752x803

saveRDS(pf, "../input/Pf_Gustafsdottir_hitSelection_featSel_pearsonCorr.rds")

```

Remark: depending on the random distribution, the number of compounds selected can vary. 
Should find a way to have stabilization.



