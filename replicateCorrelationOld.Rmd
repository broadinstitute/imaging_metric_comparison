---
title: "replicateCorrelationOld"
output: html_document
---
This markdown calculate the correlation for the old data.
The goal is to do some Hit Selection. Selecting the compound that have effects, that are showing a phenotype.
Find the median replicate correlation.
Use Pearson correlation.

Use different type of correlation metric

## Data

The input data is a 7680 by 803 matrix.
There are 7680 different observations and 799 features (extracted with CellProfiler).
Each compound (1600 different) has 4 replicates. The negative control has 1280 replicates.
20 plates with 384 wells in each plate.

```{r setup, include=FALSE}
# all usefull libraries
library(magrittr)
library(dplyr)
library(ggplot2)
library(foreach)
library(doMC)
library(stringr)
library(tidyverse)
```

## Parameter
```{r parameter}
# name of the data file
#filename <- "Pf_Gustafsdottir_fs.rds" 
filename <- "Pf_Gustafsdottir.rds"

# method of correlation: "pearson", "kendall", "spearman"
cor.method <- "pearson"
# number of data to make the non replicate correlation
N <- 5000

# seed for the reproducibility
set.seed(42)
```

## Import data
```{r import data}
# import data
pf <- readRDS(file.path("..", "..", "input", "BBBC022_2013", "old", filename)) # 7680x803

# Remove the negative control from the data
pf$data <- filter(pf$data, !Image_Metadata_BROAD_ID %in% "") # 6400x803

```

## Separation of data

Separation is made according to the compound that was added.
Image_Metadata_BROAD_ID = gives the ID of the compound that was added.

```{r separation of data}
# find the different compounds
IDs <- distinct(pf$data, Image_Metadata_BROAD_ID)
dim(IDs)
```

## Correlation of the data

Calculate the correlation of the replicate for each compound.
In an ideal case, all the correlation should be 1, meaning that they are highly correlated.

```{r correlation in parallel}
# computational time
start.time <- Sys.time()

registerDoMC(7)  # number of CPU cores  

comp.cor.median <- foreach(i = 1:length(IDs$Image_Metadata_BROAD_ID), .combine=cbind) %dopar% {

  #filtering to choose only for one compound
  comp <- filter(pf$data, Image_Metadata_BROAD_ID %in% IDs$Image_Metadata_BROAD_ID[i])
  comp <-
    comp[, pf$feat_cols] %>%
    as.matrix()

  # correlation of the features
  comp.cor <- cor(t(comp), method = cor.method)
  
  # save median of the correlation
  comp.cor.median <- median(comp.cor[lower.tri(comp.cor)],na.rm=TRUE) # 1600 values

}

end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 27.21 secs instead of 1.179 minutes

hist(comp.cor.median,
     main="Histogram for Median Replicate Correlation",
     xlab="Median Replicate Correlation", xlim = range(-1, 1))
```

If the value is equal to 1 it means that it is changing in the same direction (total positive linear correlation). 
0 means that they are unrelated (no linear correlation). 
-1 means that they are opposite (total negative linear correlation).
As expected for the replicate we can see that the distribution is bigger than 0 meaning that there are positively correlated.

## Thresholding of poor replicate correlation

H0: median non replicate correlation.

The Null distribution is estimated by finding the median correlation of non replicates. 
Select randomly 4 replicates each coming for a different compound and calculate the median correlation. 
Repeat this N times to get a distribution.
Finally estimate a threshold (95th percentile) to filter out compounds with poor replicate correlation.

```{r replicate correlation} 
# computational time
start.time <- Sys.time()

# set seed for reproducibility
set.seed(42)

# random sequence for reproducibility
a <- sample(1:10000, N, replace=F)

# loop over N times to get a distribution
random.replicate.cor.median <- foreach(i = 1:N, .combine=cbind) %dopar% {
  # set seed according to random sequence
  set.seed(a[i])
  
  # group by IDs
  # sample fixed number per group -> choose 4 replicates randomly from different group
  random.replicate <- 
    pf$data %>% 
    group_by(Image_Metadata_BROAD_ID) %>% 
    sample_n(1, replace = FALSE) %>% # choose randomly 1 sample for each group of IDs
    ungroup(random.replicate)
  # choose randomly 4 samples each coming from a different group
  random.replicate <- sample_n(random.replicate, 4, replace = FALSE)
  
  # select only the features
  comp <- random.replicate[,pf$feat_cols] %>% 
    as.matrix()
  
  # correlation of the features using the method defined in the parameter (pearson, spearman, kendall)
  random.replicate.cor <- cor(t(comp), method = cor.method)
  
  # median of the non replicate correlation
  random.replicate.cor.median <- median(random.replicate.cor[lower.tri(random.replicate.cor)],na.rm=TRUE) # vector length N
  
}

end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 1.35mins instead of 4.44 mins

# histogram plot
hist(random.replicate.cor.median,
     main="Histogram for Non Replicate Median Correlation",
     xlab="Non Replicate Median Correlation", xlim = range(-1, 1))

# threshold to determine if can reject H0
thres <- quantile(random.replicate.cor.median, .95)
print(thres)
```
As expected the distribution is around 0. Meaning that the features does not show a linear correlation.

## Hit Selection

Select strong replicates correlation comparing with the 95th percentile of the Null Distribution.

```{r Hit Selection}
# find indices of replicate median correlation > threshold
inds <- which(comp.cor.median > thres) # 938 out of 1600

# find values of the median that are hit selected
hit.select <- comp.cor.median[inds]

# find component that are hit selected
hit.select.IDs <- IDs$Image_Metadata_BROAD_ID[inds]

# ratio of strong median replicate correlation
high.median.cor <- length(hit.select)/length(comp.cor.median)
print(high.median.cor)

```

## Saving data

```{r output data}
# select high median correlation replicate 
pf$data %<>% 
  filter(Image_Metadata_BROAD_ID %in% hit.select.IDs)

# save new dataset
pf %>%
  saveRDS("../../input/BBBC022_2013/old/Hit_pearson_5925.rds")

```


Remark: depending on the random distribution, the number of compounds selected can vary. 
Maybe should find a way to reach stabilization.